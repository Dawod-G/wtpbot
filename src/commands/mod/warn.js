/**
 * @author Lothaire Guée
 * @description
 *      Contains the command 'ping'.
 *      Pong the user.
 */

const { SlashCommandBuilder } = require("@discordjs/builders");
const { getMs } = require("../../utils/dateUtils");
const { getSetupData, warnedUsers } = require("../../utils/enmapUtils");
const JSONPenalties = require(`${process.cwd()}/files/sanctions.json`);

/* ----------------------------------------------- */
/* COMMAND BUILD                                   */
/* ----------------------------------------------- */
const slashCommand = new SlashCommandBuilder()
    .setName("warn")
    .setDescription(
        "[mod] Warn un membre pour son comportement au sein du serveur."
    )
    .addStringOption(reason =>
		reason
            .setName('raison')
			.setDescription('La raison de la sanction.')
			.setRequired(true)
			.addChoices(
				{ name: 'Spam', value: 'spam' },
				{ name: 'Mass Ping', value: 'mass_ping' },
				{ name: 'Ping au staff inutile', value: 'staff_ping_inutile' },
				{ name: 'Contenu inapproprié', value: 'contenu_inapproprie' },

				{ name: 'Humour Noir', value: 'hn' },
				{ name: 'NSFW', value: 'nsfw' },
				{ name: 'Politique', value: 'politique' },

				{ name: 'Violence extrême', value: 'violence_extreme' },

				{ name: 'Fake Report', value: 'fake_report' },

				{ name: 'Gore', value: 'gore' },
				{ name: 'Pub', value: 'pub' },
				{ name: 'Haine', value: 'haine' },
				{ name: 'Discrimination', value: 'discrimination' },
				{ name: 'Troll', value: 'troll' },
				{ name: 'Non-respect du staff', value: 'non_respect_staff' },
				{ name: 'Harcèlement', value: 'harcelement' },

				{ name: 'Raid', value: 'raid' },

				{ name: 'Photo de profil pornographique', value: 'pp_porno' },

            )
    )
    .addUserOption(user =>
        user
            .setName("user")
            .setDescription("L'utilisateur faisant l'objet de l'avertissement.")
			.setRequired(true)
    )
    .addStringOption(reasonSup =>
        reasonSup
            .setName("raison_supp")
            .setDescription("Raison supplémentaire à ajouter au vu du contexte")
    )
    .setDefaultPermission(false);

/* ----------------------------------------------- */
/* FUNCTIONS                                       */
/* ----------------------------------------------- */


async function penalty(member, reason, sanction, reasonS, timeoutBase){
    // Timeout du membre
    switch (sanction) {
        case "kick":
            await member.kick(`Warn pour la sanction ${reason}.`)
            break;
        case "ban":
            await member.ban({reason: `Warn pour la sanction ${reason}.`})
            break;
        default:
            // eslint-disable-next-line no-case-declarations
            let timeoutBaseGood = timeoutBase - Date.now();
            if(timeoutBaseGood < 0) timeoutBaseGood = 0;
            if(reasonS === null)
                member.timeout(getMs(sanction) + timeoutBaseGood, `Raison : ${reason}`);
            else
                member.timeout(getMs(sanction) + timeoutBaseGood, `Raison : ${reason}, Raison supplémentaire : ${reasonS}`);
        break;
    }
}



/**
 * Function called when the command 'ping'
 * @param {CommandInteraction} interaction The interaction generated by the command's execution.
 */
async function execute(interaction) {


    for (let i = 0; i < JSONPenalties.sanctions.length; i++) {
        for (let j = 0; j < JSONPenalties.sanctions[i].reasons.length; j++) {
            if(interaction.options.getString("raison") === JSONPenalties.sanctions[i].reasons[j]){
                const reason = JSONPenalties.enum[interaction.options.getString("raison")];
                const reasonS = interaction.options.getString("raison_supp");
                const member = interaction.options.getMember("user")
                const userDB = await getSetupData(member.id, "warn_user")
                const timeoutBase = member.communicationDisabledUntilTimestamp


                // Le cas ou l'utilisateur n'a pas encore été warn / Utilise son intervalle de temps du droit à l'erreur
                if(userDB === undefined){
                    // On set l'utilisateur dans la DB
                    warnedUsers.set(member.id, {sanctions : { [reason] : -1 }, timestamp : Date.now()});

                    // On envoie le message à l'utilisateur
                    try{await member.send("Vous avez été warn pour la sanction **" + reason + "**.")}
                    catch(e){console.log(`Impossible d'envoyer le message de warn à l'utilisateur ${member.user.username} (${member.id})`)}
                    await interaction.reply({ content: "L'utilisateur n'avait pas encore été warn du tout, il vient d'être enregistré dans la base de données et bénéficie de son droit à l'erreur.", ephemeral: true });
                    return


                } else if(userDB.timestamp === undefined || userDB.sanctions[reason] === undefined){
                    
                    userDB.sanctions[reason] = 0;
                    // On set l'utilisateur dans la DB
                    warnedUsers.set(member.id, userDB)

                    const sanction = JSONPenalties.sanctions[i].values[userDB.sanctions[reason]]

                    
                    // On envoie le message à l'utilisateur
                    try{await member.send(`Vous avez été warn **${userDB.sanctions[reason]+1} fois** pour ${reason}. Sanction **${sanction}** (j:h:m) appliqué.\n**Warn par ${interaction.member.user.username}** (${interaction.member.user.id})`)}
                    catch(e){console.log(`Impossible d'envoyer le message de warn à l'utilisateur ${member.user.username} (${member.id})`)}
                    penalty(member, reason, sanction, reasonS, timeoutBase)
                    await interaction.reply({ content: `L'utilisateur n'avait pas encore été warn pour cette sanction. Sanction **${sanction}** (j:h:m) appliqué.`, ephemeral: true });
                    return


                    // Déjà vu mais n'a pas encore dépassé le temps de l'intervalle d'erreur
                } else if (userDB.timestamp + getMs(JSONPenalties.sanctions[i].timeout) > Date.now() && userDB.sanctions[reason] !== null){

                    await interaction.reply({ content: `Cet utilisateur a déjà été warn pour une sanction mais reste dans l'intervalle de temps du droit à l'erreur. (${JSONPenalties.sanctions[i].timeout} (j:h:m))\n` +
                    "En cas d'urgence : Si vous pensez que ce dernier n'a pas sa place dans le serveur et qu'il n'y a pas besoin de droit à l'erreur pour comprendre que l'utilisateur est dangeureux," +
                    "vous pouvez utiliser la commande 'ban' pour le bannir.", ephemeral: true });
                    try{await member.send(`Vous avez été warn pour la sanction ${reason} mais cela reste dans l'intervalle de temps du droit à l'erreur.`)}
                    catch(e){console.log(`Impossible d'envoyer le message de warn à l'utilisateur ${member.user.username} (${member.id})`)}
                    return


                    // SANCTION
                } else if (userDB.timestamp + getMs(JSONPenalties.sanctions[i].timeout) < Date.now() && userDB.sanctions[reason] !== null){

                    // On augmente le nombre de raison que l'on update dans la db en remettant l'objet
                    userDB.sanctions[reason]++;
                    warnedUsers.set(member.id, userDB)

                    // Si on dépasse la plus grande valeur de timeout du tableau, on le remet à la valeur max
                    let nbSanctions = userDB.sanctions[reason];
                    if(nbSanctions >= JSONPenalties.sanctions[i].values.length) nbSanctions = JSONPenalties.sanctions[i].values.length - 1;

                    const sanction = JSONPenalties.sanctions[i].values[nbSanctions] 

                    // On envoie le message à l'utilisateur et on applique le timeout
                    
                    const nbTimes = userDB.sanctions[reason]+1;
                    
                    try{await member.send(`Vous avez été warn **${nbTimes} fois** pour ${reason}. Sanction **${sanction}** (j:h:m) appliqué.\n**Warn par ${interaction.member.user.username}** (${interaction.member.user.id})`)}
                    catch(e){console.log(`Impossible d'envoyer le message de warn à l'utilisateur ${member.user.username} (${member.id})`)}
                    penalty(member, reason, sanction, reasonS, timeoutBase)
                    await interaction.reply({ content: `${member.user.username} (${member.id}) a déjà été warn ${nbTimes} fois pour cette sanction "${reason}".\n**Sanction ${sanction} (j:h:m) appliqué.**`, ephemeral: true })
                    return
                }
            }
        }
    }
}

/* ----------------------------------------------- */
/* MODULE EXPORTS                                  */
/* ----------------------------------------------- */
module.exports = {
    data: slashCommand,
    execute,
};
